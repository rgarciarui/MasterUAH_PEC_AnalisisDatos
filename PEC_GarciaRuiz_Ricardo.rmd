---
title: "PEC_Analisis Datos R"
author: "Ricardo Garcia Ruiz"
date: '`r format(Sys.Date(),"%e de %B, %Y")`'
output:
  html_document:
    toc: TRUE
    theme: lumen
    highlight: tango
    number_sections: true
    toc_depth: 4
  word_document:
    toc: TRUE
    highlight: default
    toc_depth: 4
  pdf_document:
    toc: TRUE
    highlight: default
    number_sections: true
    toc_depth: 4
  rmdformats::readthedown:
    highlight: kate
    use_bookdown: TRUE
    self_contained: true
    thumbnails: true
    lightbox: true
    gallery: false
---


```{r knitr_init, echo=FALSE, cache=FALSE, warning=FALSE, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=FALSE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
library(tidyverse)

library("kableExtra")
```

# Ejercicio 1 (40%)

> El conjunto de datos bikes2016.csv contiene información sobre el número de personas que circulan en bicicleta por cada uno de los distritos de la ciudad de Montreal a lo largo del año 2016 http://donnees.ville.montreal.qc.ca/dataset/velos-comptage. En este conjunto de datos, las filas representan los dias del año y las columnas cada uno de los distritos. La columna 2 contiene un timestamp que vamos a ignorar. Sobre este conjunto de datos:


## (5 puntos) Leer el fichero bikes2016.csv como un dataframe

Cargamos el conjunto de datos desde el fichero 'bikes2016.csv' y lo mostramos: 

```{r pregunta_1, echo=FALSE}
bikes <- read_csv("bikes2016.csv")

str(bikes)

```

y podemos ver la estructura de datos que tiene nuestro dataframe cuando se carga mediante y tibble de tydiverse.

Los datos se pueden verificar en la siguiente tabla:

```{r pregunta_1.1, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
kable(cbind(bikes, bikes), caption = "Datos bikes2016.csv") %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "200px")
```


## (5 puntos) Eliminar la columna **Timestamp** del dataframe.

La variables 'timestamp' se encuentra localizada en la segunda columna por lo que lo más sencillo es eliminar esa columna del conjunto de datos.

```{r pregunta_2, echo=FALSE}
bikes <- dplyr::select(bikes, -Timestamp)

str(bikes)

```


## (10 puntos) Calcular el porcentaje de missing values en cada una de las columnas.

Esta accion se puede abordar de diferente maneras, incluyendo el uso de la librería **dplyr**. Por ejemplo con '**bikes %>% map(~ mean(is.na(.)))**'. No obsante, vamos a usar una variante que nos permite su representación en forma de tabla:


```{r pregunta_3, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes %>% 
  summarise_all(funs(100*mean(is.na(.)))) %>% kable() %>%
  kable_styling() %>%
  scroll_box(width = "100%", height = "200px")
```


## (10 puntos) Identificar cuales son las variables que están contenidas en el data.frame. A continuación, transformar ese data.frame para que cada columna represente cada una de las variables. Usar los nombres Date, District y N.

En el tibble tenemos 2 tipos de variables:

* **Date**: que se corresponde con la fecha de la toma de cada dato.
* **Distritos**: Que se corresponde con todas y cada una de las demás columnas del dataframe.

Ahora procedemos a realizar una reunión de los datos en 3 variables:

* **Date**: que contine el cmismo conjunto de datos de tiempo originales
* **District**: que contendrá los nombres de los distritos donde se han tomado las medidas
* **N**: que contendrá el conjunto de los datos de los distritos segun su asignación en el dataframe original.

```{r pregunta_4, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes <- bikes %>%
  gather(key = District, value = N, -Date) 

bikes %>% kable() %>%
  kable_styling() %>%
  scroll_box(width = "50%", height = "200px")

```

## (10 puntos) Calcular el total de personas que pasa por cada uno de los distritos a lo largo de todo el año.

A continuación se agrupan los distritos y se calcula la suma total de personas que pasó por cada distrito en 2016:

```{r pregunta_5, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes %>%
  na.omit() %>%
  group_by(District) %>%
  summarise(personas = sum(N)) %>% kable() %>%
  kable_styling() %>%
  scroll_box(width = "50%", height = "200px")
```


## (10 puntos) Completar los missing values del atributo N con la media del resto de datos de esa variable pero agrupado de acuerdo a la variable **District**.

En este paso volvemos a proeceder a la agrupación por distrito y posteriormente se aplica la función **mutate()** para aplicar la media a calculada para cada distrito y volcarla solo a los valores NA.
Finalmente se guardan los ajustes en el dataframe.

```{r pregunta_6, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes %>%
  group_by(District) %>%
  mutate(N = ifelse(is.na(N), mean(N, na.rm = TRUE), N)) -> bikes


kable(bikes) %>%
  kable_styling() %>%
  scroll_box(width = "50%", height = "200px")

```


## (10 puntos) Crear tres nuevas variables en el data.frame **(Day, Month, Year )** que contengan la información del día, mes y año respectivamente.

Se utiliza la función **separate** para crear las 3 nuevas variables. Se elimina la variable original 'Date'.

```{r pregunta_7, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes %>%
 separate(Date, c("Day", "Month", "Year"), sep = "/") -> bikes

kable(bikes) %>%
  kable_styling() %>%
  scroll_box(width = "50%", height = "200px")
```


## (20 puntos) Realizar un gráfico de barras del número de ciclistas para cada día de la semana en cada uno de los seis districtos con más ciclistas (usando facetas)

En primer lugar vamos a ver cuales son los 5 primeros distritos por número de ciclistas:

```{r pregunta_8.1, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}

bikes %>%
  group_by(District) %>%
  summarise(ciclistas = sum(N)) %>%
  arrange(desc(ciclistas)) %>%
  slice(1:5) %>% kable

```

Una vez que sabemos este dato, procedemos a crear un filtro para poder utilizarlo en la selección de datos:

```{r pregunta_8.2, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}

filtro1 <- bikes %>%
  group_by(District) %>%
  summarise(ciclistas = sum(N)) %>%
  arrange(desc(ciclistas)) %>%
  slice(1:5) %>%
  select(-ciclistas)

kable(filtro1)

```

Ahora podemos proceder a seleccionar los datos del dataframe que cumplen con el filtro:


```{r pregunta_8.3, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}

bikes %>%
  semi_join(filtro1, by = c("District")) %>%
  arrange(District) %>%
  kable() %>%
  kable_styling() %>%
  scroll_box(width = "50%", height = "200px")

```

Y en este punto procedemos a la visualización de los datos:

```{r pregunta_8.4, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes %>%
  semi_join(filtro1, by = c("District")) %>%
  arrange(District) %>%
  ggplot(aes(x = Day, y = N)) +
  geom_point() + geom_smooth() + 
  facet_grid(District~.)

bikes %>%
  semi_join(filtro1, by = c("District")) %>%
  arrange(District) %>%
  ggplot(aes(x = Day, y = N)) +
  geom_point() + geom_smooth() + coord_flip() +
  facet_wrap(District~.)
```



## (20 puntos) Realizar un único gráfico con la evolución diaria del número de ciclistas en el mes de Enero para los districtos **Berry1**, **University**, **Boyer** y **ParcB**.

En primer lugar, vamos a verificar el conjunto de datos que se va a tratar según la propuesta:

```{r pregunta_9.1, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes %>%
  filter(District %in% c('Berri1', 'University', 'Boyer', 'Parc')) %>%
  filter(str_detect(Month, '01')) %>% 
  kable() %>%
  kable_styling() %>%
  scroll_box(width = "50%", height = "200px")
```

Ahora procederemos a realizar la gráfica conjunta de cada variable:


```{r pregunta_9.2, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
bikes %>%
  filter(District %in% c("Berri1", "University", "Boyer", "Parc")) %>%
  filter(str_detect(Month, "01")) %>%
  ggplot(aes(x = Day, y = N, group = District)) +
  geom_line(aes(color = District)) +
  geom_point(aes(color = District)) +
  labs(
    title = " Evolucion diaria del numero de ciclistas",
    x = "Dias (enero)",
    y = "Numero ciclistas"
  )
```


```{r cierre_pregunta, echo=FALSE, cache=FALSE, results = 'asis', warning=FALSE, comment=FALSE}
# eliminamos las variables de memoria para que no ocupen espacio util
rm(bikes, filtro1)
```


# Ejercicio 2 (60%)

>El conjunto de datos titanic.csv contiene información sobre los pasajeros del barco. Este conjunto de datos se ha utilizado para tratar de predecir la supervivencia de un pasajero en base a otra serie de variables como edad, sexo, o la clase del billete. Ver por ejemplo: https://www.kaggle.com/c/titanic. 
Cada una de las variables del fichero contiene la siguiente información:

* **survival:** Supervivencia (0 = No; 1 = Yes)
* **pclass:** Clase de pasajero (1, 2, 3)
* **name:** Nombre
* **sex:** Sexo
* **age:** Edad
* **sibsp:** Número de hermanos/esposos/as a bordo.
* **parch:** Número de padres/hijos a bordo
* **ticket:** Número de ticket
* **fare:** Coste del billete
* **cabin:** Cabina
* **embarked:** Puerto de embarque

Con el fichero de datos anterior:

## (4 puntos) Leer el fichero **titanic.csv** como un dataframe.



## (2 puntos) Calcular el porcentaje de pasajeros que sobrevivió.

Cargamos el conjunto de datos desde el fichero 'titanic.csv' y lo mostramos: 

```{r pregunta_1, echo=FALSE}
titanic <- read_csv("titanic.csv")

str(titanic)

```


## (4 puntos) Calcular el porcentaje de missing values en cada uno de los atributos.

## (2 puntos) Eliminar la variable **Cabin** del dataframe.

## (8 puntos) Crear una nueva variable **Title** a partir de **Name** con los valores **Master** (hombre soltero), **Miss** (mujer soltera), **Mr.** (hombre casado), **Mrs.** (mujer casada) y Otro a partir de la variable **nombre**. Es importante tener en cuenta que el título **Miss** está en ocasiones codificado con su abreviatura en frances **Mlle** (mademoiselle) y lo mismo ocurre con **Mrs.**, que en ocasiones aparece como **Ms.** ó **Mme** (madame).

## (4 puntos) Explorar la relación entre las variables **Age** y la nueva variable **Title** mediante un boxplot para cada uno de los valores de la misma. ¿Tienen alguna relación?.

## (4 puntos) Explorar la relación entre **Age**, **Pclass** y **Title** en varios gráficos de dispersión con colores, donde el color representa la supervivencia (Pista: usar facetas).

## (8 puntos) Completar los missing values del atributo **Age** con la mediana del resto de datos de esa variable pero agrupado de acuerdo a las variables **Pclass** y **Title**.

## (2 puntos) Después de realizar las operaciones anteriores, eliminar ahora cualquier fila que tenga al menos un NA.

## (2 puntos) Calcular la probabilidad de supervivencia en base al género (Sex). ¿Qué conclusión(es) obtienes del resultado?

## (2 puntos) Calcular la probabilidad de supervivencia en base a la edad (**Age**). ¿Te parecen fácilmente interpretables estos resultados?

## (4 puntos) Crea una nueva variable **Decade** en el dataframe que contenga la década de la edad de los pasajeros y repite el análisis del apartado anterior sobre esta nueva variable. ¿Qué conclusión(es) obtienes del resultado? Pista: función cut.

## (4 puntos) Convertir la variable **Survived** a un factor con los niveles Yes si ha sobrevivido y No en caso contrario.

## (4 puntos) Ver la relación entre la supervivencia y la nueva variable Title con un gráfico de barras. En el caso del valor **Otros** de la variable **Title**, ¿nos proporciona este alguna información sobre la supervivencia?. ¿A qué se debe?

## (4 puntos) Crea dos nuevas variables en el dataframe con la siguiente información:

* **Familysize:** número total de parientes incluyendo al propio pasajero. 
* **Sigleton:** valor lógico indicando con valor TRUE si el pasajero viaja solo y FALSE en caso contrario.


## (4 puntos) Realizar un gráfico de puntos de la variable **Age** sobre **Fare**, coloreado por los valores de la variable **Survived**.

## (2 puntos) Realizar un histograma para ver la distribución de las edades.

## (4 puntos) Representar en un gráfico de barras el número de pasajeros que han sobrevivido para cada uno de los valores de las variables **Sex** y **Pclass**.

## (4 puntos) Cuenta el número de pasajeros por tamaño de familia y clase. Por ejemplo, cuántos pasajeros de primera clase pertenecen a una familia de tamaño 4. El resultado debe ser un dataframe con la información para todas las posibles combinaciones de clase del billete y tamaño de familia.

## (4 puntos) Representar, en un mismo gráfico, dos histogramas de la variable **Age**, uno para los pasajeros con sexo masculino y otro para los pasajeros con sexo femenino. En caso de que se solapen los histogramas, usar colores con transparencias.

## (4 puntos) Leer el fichero **titanic2.csv**, que contiene información adicional sobre los pasajeros del barco:
* **boat:** identificador del bote salvavidas
* **body:** identificador del cuerpo
* **home.dest:** Origen/destino

## (4 puntos) Para unificar estos dos dataframes, parecería buena opción utilizar la variable name como clave. Determina si esta variable es única por pasajero, mostrando el número de nombres diferentes repetidos. En caso de existir varios pasajeros con el mismo nombre, listar aquellas filas del dataframe inicial en las que el nombre del pasajero esté repetido

## (6 puntos) Combina ambos dataframes utilizando la combinación del nombre y el número de billete, manteniendo las mismas filas que el dataframe original.

## (4 puntos) ¿Qué porcentaje de los pasajeros que sobrevivió tiene asociado un identificador del bote salvavidas?

## (6 puntos) Separar el conjunto anterior de datos en dos subconjuntos disjuntos de forma aleatoria, el primero conteniendo un 70% de los datos y el segundo un 30%. Los resultados tienen que estar contenidos en dos dataframes















